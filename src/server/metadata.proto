// Copyright (c) 2013, Cloudera, inc.

package kudu.metadata;

import "common/common.proto";

// ============================================================================
//  Local file system metadata
// ============================================================================

// When any server initializes a new filesystem (eg a new node is created in the
// cluster), it creates this structure and stores it persistently.
message InstanceMetadataPB {

  // The UUID which is assigned when the instance is first formatted. This uniquely
  // identifies the node in the cluster.
  required bytes uuid = 1;

  // Human-readable string indicating when and where the node was first
  // initialized.
  required string format_stamp = 2;

  // TODO: add a "node type" (TS/Master?)
}

// ============================================================================
//  Tablet Metadata
// ============================================================================

message BlockIdPB {
  required string id = 1;
}

message ColumnDataPB {
  required BlockIdPB block = 2;
  required ColumnSchemaPB schema = 3;
}

message DeltaDataPB {
  required uint64 id = 1;
  required BlockIdPB block = 2;
}

message RowSetDataPB {
  required uint64 id = 1;
  required int64 last_durable_dms_id = 2;
  repeated ColumnDataPB columns = 3;
  repeated DeltaDataPB redo_deltas = 4;
  repeated DeltaDataPB undo_deltas = 5;
  optional BlockIdPB bloom_block = 6;
  optional BlockIdPB adhoc_index_block = 7;
}

// The super-block keeps track of the tablet data blocks.
// A tablet contains one or more RowSets, which contain
// a set of blocks (one for each column), a set of delta blocks
// and optionally a block containing the bloom filter
// and a block containing the compound-keys.
message TabletSuperBlockPB {
  // SuperBlock sequence number.
  // This is incremented every time the superblock is successfully written,
  // in order to easily alternate between block_a and block_b.
  required uint64 sequence = 1;

  // Tablet Id
  // TODO: rename to tablet_id
  required string oid = 2;

  // The latest durable MemRowSet id
  required int64 last_durable_mrs_id = 3;

  // Tablet start-key
  required bytes start_key = 4;

  // Tablet end-key
  required bytes end_key = 5;

  // Tablet RowSets
  repeated RowSetDataPB rowsets = 6;

  // The latest schema
  // TODO: maybe this should be TableSchemaPB? Need to actually put those attributes
  // into use throughout the code. Using the simpler one for now.
  required string table_name = 7;
  required SchemaPB schema = 8;
  required uint32 schema_version = 9;

  // The latest QuorumPB this tablet was part of.
  // TODO make this required once dist consensus is fully integrated.
  optional QuorumPB quorum = 10;
}

// The enum of tablet states.
// Tablet states are sent in TabletReports and kept in TabletPeer.
enum TabletStatePB {

  // Indicates the Tablet is bootstrapping, i.e. that the Tablet is not
  // available for RPC.
  BOOTSTRAPPING = 0;

  // Indicates the Tablet is in the configuration phase. Tablet is available
  // for internal RPC calls (i.e. from other Peers) but not available to
  // clients.
  // FOLLOWER Peers will remain in this state until a message containing the
  // current configuration is received from the LEADER. Upon creating a new
  // connection to a Peer, the LEADER always sends the current configuration
  // first.
  // LEADER Peers will remain in this state until they are able to replicate
  // the configuration message where they are LEADER.
  CONFIGURING = 1;

  // Once the configuration phase is over Peers are in RUNNING state. In this
  // state Peers are available for client RPCs.
  RUNNING = 2;

  // The tablet failed to for some reason. TabletPeer::error() will return
  // the reason for the failure.
  FAILED = 3;

  // The Tablet is shutting down, and will not accept further requests.
  QUIESCING = 4;

  // The Tablet has been stopped.
  SHUTDOWN = 5;
}

// The master-block contains the two block-ids required to load the
// tablet super-block. The master-block is immutable and written to the
// "bootstrap table", on tablet creation, and it is used by the master
// to load all the tablets in the system at startup.
message TabletMasterBlockPB {
  required bytes table_id = 1;
  required bytes tablet_id = 2;
  required bytes block_a = 3;
  required bytes block_b = 4;
}

// ===========================================================================
//  Consensus Metadata
// ===========================================================================

// A peer in a quorum.
message QuorumPeerPB {
  // The possible roles for quorum peers.
  enum Role {
    // Indicates this node is a follower in the quorum, i.e. that it participates
    // in majorities and accepts Consensus::Update() calls.
    FOLLOWER = 0;
    // Indicates this node is a leader candidate in the quorum, i.e. that it
    // that it behaves as FOLLOWER and can be elected LEADER.
    CANDIDATE = 1;
    // Indicates this node is the current leader of the quorum, i.e. that it
    // participates in majorities and accepts Consensus::Append() calls.
    LEADER = 2;
    // Indicates that this node participates in the quorum in a passive role,
    // i.e. that it accepts Consensus::Update() calls but does not participate
    // in elections or majorities.
    LEARNER = 4;
    // Indicates that this node is not a participant of the quorum, i.e. does
    // not accept Consensus::Update() or Consensus::Update() and cannot
    // participate in elections or majorities. This is usually the role of a node
    // that leaves the quorum.
    NON_PARTICIPANT = 5;
    // Indicates that this peer does not know its role in this particular quorum.
    UNKNOWN = 6;
  };
  required bytes permanent_uuid = 1;
  optional Role role = 2;
  optional HostPortPB last_known_addr = 3;
}

// A set of quorum peers, serving a single tablet.
message QuorumPB {
  // the sequence number of the quorum configuration.
  required int64 seqno = 1;
  // whether this is a local or distributed quorum (i.e. whether to use a local or dist
  // implementation of consensus).
  optional bool local = 2 [default = true];
  // the set of peers in the quorum.
  repeated QuorumPeerPB peers = 3;
}
