// Copyright (c) 2012, Cloudera, inc.
//
// Protobufs which are common throughout Kudu.
//
// This file may contain protobufs which are persisted on disk
// as well as sent on the wire. If a particular protobuf is only
// used as part of the client-server wire protocol, it should go
// in common/wire_protocol.proto instead. If it is only used within
// the server(s), it should go in cfile/cfile.proto, server/metadata.proto,
// etc, as appropriate.
package kudu;

// If you add a new type keep in mind to add it to the end
// or update AddMapping() functions like the one in key_encoder.cc
// that have a vector that maps the protobuf tag with the index.
//
// TODO: once KeyEncoder is implemented for BOOL, change its
// enum value to 0 (if enum value for BOOL is 0, existing unit tests
// test the KeyEncoder for BOOL, which is not yet implemented).
enum DataType {
  UINT8 = 0;
  INT8 = 1;
  UINT16 = 2;
  INT16 = 3;
  UINT32 = 4;
  INT32 = 5;
  UINT64 = 6;
  INT64 = 7;
  STRING = 8;
  BOOL = 9;
}

enum EncodingType {
  AUTO_ENCODING = 0;
  PLAIN_ENCODING = 1;
  PREFIX_ENCODING = 2;
  GROUP_VARINT = 3;
  RLE = 4;
}

enum CompressionType {
  DEFAULT_COMPRESSION = 0;
  NO_COMPRESSION = 1;
  SNAPPY = 2;
  LZ4 = 3;
  ZLIB = 4;
}

// TODO: Differentiate between the schema attributes
// that are only relevant to the server (e.g.,
// encoding and compression) and those that also
// matter to the client.
message ColumnSchemaPB {
  optional uint32 id = 1;
  required string name = 2;
  required DataType type = 3;
  optional bool is_key = 4 [default = false];
  optional bool is_nullable = 5 [default = false];
  optional bytes read_default_value = 6;
  optional bytes write_default_value = 7;
  optional EncodingType encoding = 8 [default=AUTO_ENCODING];
  optional CompressionType compression = 9 [default=DEFAULT_COMPRESSION];
}

message SchemaPB {
  repeated ColumnSchemaPB columns = 1;
}

message HostPortPB {
  required string host = 1;
  required uint32 port = 2;
}

  // The external consistency mode for client requests.
  // This defines how transactions and/or sequences of operations that touch
  // several TabletServers, in different machines, can be observed by external
  // clients.
  //
  // Note that ExternalConsistencyMode makes no guarantee on atomicity, i.e.
  // no sequence of operations is made atomic (or transactional) just because
  // an external consistency mode is set.
  // Note also that ExternalConsistencyMode has no implication on the
  // consistency between replicas of the same tablet.
enum ExternalConsistencyMode {

    // The server will make no attempt at guaranteeing external
    // consistency.
    //
    // Example:
    // 1 - Client A executes operation X in Tablet A
    // 2 - Afterwards, Client A executes operation Y in Tablet B
    //
    //
    // Client B may observe the following operation sequences:
    // {}, {X}, {Y}, {X Y}, {Y X}
    //
    // This is the default mode.
    NO_CONSISTENCY = 1;

    // The response to any write will contain a timestamp.
    // Any further calls from the same client to other servers will update
    // those servers with that timestamp. The user will make sure that the
    // timestamp is propagated through back-channels to other
    // KuduClient's.
    //
    // WARNING: Failure to propagate timestamp information through
    // back-channels will negate any external consistency guarantee under this
    // mode.
    //
    // Example:
    // 1 - Client A executes operation X in Tablet A
    // 2 - Afterwards, Client A executes operation Y in Tablet B
    //
    //
    // Client B may observe the following operation sequences:
    // {}, {X}, {X Y}
    CLIENT_PROPAGATED = 2;

    // The server will guarantee that each transaction is externally
    // consistent by making sure that none of its results are visible
    // until every Kudu server agrees that the transaction is in the past.
    // The client is not obligated to forward timestamp information
    // through back-channels.
    //
    // WARNING: Depending on the clock synchronization state of TabletServers
    // this may imply considerable latency. Moreover operations with
    // COMMIT_WAIT requested external consistency will outright fail if
    // TabletServer clocks are either unsynchronized or synchronized but
    // with a maximum error which surpasses a pre-configured one.
    //
    // Example:
    // - Client A executes operation X in Tablet A
    // - Afterwards, Client A executes operation Y in Tablet B
    //
    //
    // Client B may observe the following operation sequences:
    // {}, {X}, {X Y}
    COMMIT_WAIT = 3;
};

// The possible read modes for clients.
// Clients set these in Scan requests.
// The server keeps 2 snapshot boundaries:
// - The earliest snapshot: this corresponds to the earliest kept undo records
//   in the tablet, meaning the current state (Base) can be undone up to
//   this snapshot.
// - The latest snapshot: This corresponds to the instant beyond which no
//   no transaction will have an earlier timestamp. Usually this corresponds
//   to whatever clock->Now() returns, but can be higher if the client propagates
//   a timestamp (see below).
enum ReadMode {

  // When READ_LATEST is specified the server will execute the read independently
  // of the clock and will always return all visible writes at the time the request
  // was received. This type of read does not return a snapshot timestamp since
  // it might not be repeatable, i.e. a later read executed at the same snapshot
  // timestamp might yield rows that were committed by in-flight transactions.
  //
  // This is the default mode.
  READ_LATEST = 1;

  // When READ_AT_SNAPSHOT is specified the server will attempt to perform a read
  // at the required snapshot. If no snapshot is defined the server will take the
  // current time as the snapshot timestamp. Snapshot reads are repeatable, i.e.
  // all future reads at the same timestamp will yield the same rows. This is
  // performed at the expense of waiting for in-flight transactions whose timestamp
  // is lower than the snapshot's timestamp to complete.
  //
  // When mixing reads and writes clients that specify COMMIT_WAIT as their
  // external consistency mode and then use the returned write_timestamp to
  // to perform snapshot reads are guaranteed that that snapshot time is
  // considered in the past by all servers and no additional action is
  // necessary. Clients using CLIENT_PROPAGATED however must forcibly propagate
  // the timestamps even at read time, so that the server will not generate
  // any more transactions before the snapshot requested by the client.
  // The latter option is implemented by allowing the client to specify one or
  // two timestamps, the first one obtained from the previous CLIENT_PROPAGATED
  // write, directly or through back-channels, must be signed and will be
  // checked by the server. The second one, if defined, is the actual snapshot
  // read time. When selecting both the latter must be lower than or equal to
  // the former.
  // TODO implement actually signing the propagated timestamp.
  READ_AT_SNAPSHOT = 2;
}