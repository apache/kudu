<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Kudu C++ client API: kudu::client::KuduSession Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kudu C++ client API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>kudu</b></li><li class="navelem"><b>client</b></li><li class="navelem"><a class="el" href="classkudu_1_1client_1_1KuduSession.html">KuduSession</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classkudu_1_1client_1_1KuduSession-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">kudu::client::KuduSession Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Representation of a Kudu client session.  
 <a href="classkudu_1_1client_1_1KuduSession.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="client_8h_source.html">client.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for kudu::client::KuduSession:</div>
<div class="dyncontent">
<div class="center"><img src="classkudu_1_1client_1_1KuduSession__inherit__graph.png" border="0" usemap="#kudu_1_1client_1_1KuduSession_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for kudu::client::KuduSession:</div>
<div class="dyncontent">
<div class="center"><img src="classkudu_1_1client_1_1KuduSession__coll__graph.png" border="0" usemap="#kudu_1_1client_1_1KuduSession_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aaec3956e642610d703f3b83b78e24e19"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#aaec3956e642610d703f3b83b78e24e19">FlushMode</a> { <a class="el" href="classkudu_1_1client_1_1KuduSession.html#aaec3956e642610d703f3b83b78e24e19ad74b76e407e62ca951d369521636df2b">AUTO_FLUSH_SYNC</a>, 
<a class="el" href="classkudu_1_1client_1_1KuduSession.html#aaec3956e642610d703f3b83b78e24e19a520b8eef7ef0fd149b2757faf43972b1">AUTO_FLUSH_BACKGROUND</a>, 
<a class="el" href="classkudu_1_1client_1_1KuduSession.html#aaec3956e642610d703f3b83b78e24e19a1db3efc2094da09aae45bb68475cdb4a">MANUAL_FLUSH</a>
 }<tr class="memdesc:aaec3956e642610d703f3b83b78e24e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modes of flush operations.  <a href="classkudu_1_1client_1_1KuduSession.html#aaec3956e642610d703f3b83b78e24e19">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aaec3956e642610d703f3b83b78e24e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd55109ba3b086bbe33b277cdd40d22"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#aabd55109ba3b086bbe33b277cdd40d22">ExternalConsistencyMode</a> { <a class="el" href="classkudu_1_1client_1_1KuduSession.html#aabd55109ba3b086bbe33b277cdd40d22ae978fab7451faebf4399830b603c855c">CLIENT_PROPAGATED</a>, 
<a class="el" href="classkudu_1_1client_1_1KuduSession.html#aabd55109ba3b086bbe33b277cdd40d22a70010f3ef1f70b99b02328c024c436c9">COMMIT_WAIT</a>
 }<tr class="memdesc:aabd55109ba3b086bbe33b277cdd40d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible external consistency modes on which Kudu operates.  <a href="classkudu_1_1client_1_1KuduSession.html#aabd55109ba3b086bbe33b277cdd40d22">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aabd55109ba3b086bbe33b277cdd40d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a83555781b5a037f87c215e565ecf1a8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#a83555781b5a037f87c215e565ecf1a8f">SetFlushMode</a> (<a class="el" href="classkudu_1_1client_1_1KuduSession.html#aaec3956e642610d703f3b83b78e24e19">FlushMode</a> m) WARN_UNUSED_RESULT</td></tr>
<tr class="separator:a83555781b5a037f87c215e565ecf1a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d1c7f47dfcaf5121b15a4435a8eeca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#a56d1c7f47dfcaf5121b15a4435a8eeca">SetExternalConsistencyMode</a> (<a class="el" href="classkudu_1_1client_1_1KuduSession.html#aabd55109ba3b086bbe33b277cdd40d22">ExternalConsistencyMode</a> m) WARN_UNUSED_RESULT</td></tr>
<tr class="separator:a56d1c7f47dfcaf5121b15a4435a8eeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa9bbc51c27104ce103b9ecda3b8abf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#aefa9bbc51c27104ce103b9ecda3b8abf">SetMutationBufferSpace</a> (size_t size_bytes) WARN_UNUSED_RESULT</td></tr>
<tr class="separator:aefa9bbc51c27104ce103b9ecda3b8abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7311344cec37b3847217197c35467cdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#a7311344cec37b3847217197c35467cdf">SetMutationBufferFlushWatermark</a> (double watermark_pct) WARN_UNUSED_RESULT</td></tr>
<tr class="separator:a7311344cec37b3847217197c35467cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe75f0688f992dbdb2694a50d07f941"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#aabe75f0688f992dbdb2694a50d07f941">SetMutationBufferFlushInterval</a> (unsigned int millis) WARN_UNUSED_RESULT</td></tr>
<tr class="separator:aabe75f0688f992dbdb2694a50d07f941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a96017f86bfb6348fca9bfa0b8b5a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#ac9a96017f86bfb6348fca9bfa0b8b5a4">SetMutationBufferMaxNum</a> (unsigned int max_num) WARN_UNUSED_RESULT</td></tr>
<tr class="separator:ac9a96017f86bfb6348fca9bfa0b8b5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b22362650d7120f59cc1025e40bd79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#a25b22362650d7120f59cc1025e40bd79">SetTimeoutMillis</a> (int millis)</td></tr>
<tr class="separator:a25b22362650d7120f59cc1025e40bd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f7324b27fca298c5ca3d07b4741943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply</a> (<a class="el" href="classkudu_1_1client_1_1KuduWriteOperation.html">KuduWriteOperation</a> *write_op) WARN_UNUSED_RESULT</td></tr>
<tr class="separator:ad3f7324b27fca298c5ca3d07b4741943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64955abb5f5cc821b6e56354f733ce84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#a64955abb5f5cc821b6e56354f733ce84">Flush</a> () WARN_UNUSED_RESULT</td></tr>
<tr class="separator:a64955abb5f5cc821b6e56354f733ce84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c68570479e95b325d8a5437eef8731"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad8c68570479e95b325d8a5437eef8731">FlushAsync</a> (<a class="el" href="classkudu_1_1client_1_1KuduStatusCallback.html">KuduStatusCallback</a> *cb)</td></tr>
<tr class="separator:ad8c68570479e95b325d8a5437eef8731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5204844e361ecc3068fbc4e02fd4436"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#aa5204844e361ecc3068fbc4e02fd4436">Close</a> () WARN_UNUSED_RESULT</td></tr>
<tr class="separator:aa5204844e361ecc3068fbc4e02fd4436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f224e9b95f86da7e1f2ea6fcf327756"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#a3f224e9b95f86da7e1f2ea6fcf327756">HasPendingOperations</a> () const </td></tr>
<tr class="separator:a3f224e9b95f86da7e1f2ea6fcf327756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6249cf3bbad8e2e11e54edf40a7bc1d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#af6249cf3bbad8e2e11e54edf40a7bc1d">CountBufferedOperations</a> () const ATTRIBUTE_DEPRECATED(&quot;this method is experimental and will disappear &quot;&quot;in a future release&quot;)</td></tr>
<tr class="separator:af6249cf3bbad8e2e11e54edf40a7bc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c5e5e8faba286cddc266057e9a82d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#af1c5e5e8faba286cddc266057e9a82d5">SetErrorBufferSpace</a> (size_t size_bytes)</td></tr>
<tr class="separator:af1c5e5e8faba286cddc266057e9a82d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277c213a68679c6b0d5c432919eb9198"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#a277c213a68679c6b0d5c432919eb9198">CountPendingErrors</a> () const </td></tr>
<tr class="separator:a277c213a68679c6b0d5c432919eb9198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e3521623338de49cfd62914bdcb2f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad5e3521623338de49cfd62914bdcb2f7">GetPendingErrors</a> (std::vector&lt; <a class="el" href="classkudu_1_1client_1_1KuduError.html">KuduError</a> * &gt; *errors, bool *overflowed)</td></tr>
<tr class="separator:ad5e3521623338de49cfd62914bdcb2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed0bac1edcbba612d7de41e8c8adfd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1client_1_1KuduClient.html">KuduClient</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#a4ed0bac1edcbba612d7de41e8c8adfd5">client</a> () const </td></tr>
<tr class="separator:a4ed0bac1edcbba612d7de41e8c8adfd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Representation of a Kudu client session. </p>
<p>A <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session. ">KuduSession</a> belongs to a specific <a class="el" href="classkudu_1_1client_1_1KuduClient.html" title="A handle for a connection to a cluster. ">KuduClient</a>, and represents a context in which all read/write data access should take place. Within a session, multiple operations may be accumulated and batched together for better efficiency. Settings like timeouts, priorities, and trace IDs are also set per session.</p>
<p>A <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session. ">KuduSession</a>'s main purpose is for grouping together multiple data-access operations together into batches or transactions. It is important to note the distinction between these two:</p>
<ul>
<li>A batch is a set of operations which are grouped together in order to amortize fixed costs such as RPC call overhead and round trip times. A batch DOES NOT imply any ACID-like guarantees. Within a batch, some operations may succeed while others fail, and concurrent readers may see partial results. If the client crashes mid-batch, it is possible that some of the operations will be made durable while others were lost. </li>
<li>In contrast, a transaction is a set of operations which are treated as an indivisible semantic unit, per the usual definitions of database transactions and isolation levels.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Kudu does not currently support transactions! They are only mentioned in the above documentation to clarify that batches are not transactional and should only be used for efficiency.</dd></dl>
<p><a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session. ">KuduSession</a> is separate from <a class="el" href="classkudu_1_1client_1_1KuduTable.html" title="A representation of a table on a particular cluster. ">KuduTable</a> because a given batch or transaction may span multiple tables. This is particularly important in the future when we add ACID support, but even in the context of batching, we may be able to coalesce writes to different tables hosted on the same server into the same RPC.</p>
<p><a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session. ">KuduSession</a> is separate from <a class="el" href="classkudu_1_1client_1_1KuduClient.html" title="A handle for a connection to a cluster. ">KuduClient</a> because, in a multi-threaded application, different threads may need to concurrently execute transactions. Similar to a JDBC "session", transaction boundaries will be delineated on a per-session basis &ndash; in between a "BeginTransaction" and "Commit" call on a given session, all operations will be part of the same transaction. Meanwhile another concurrent Session object can safely run non-transactional work or other transactions without interfering.</p>
<p>Additionally, there is a guarantee that writes from different sessions do not get batched together into the same RPCs &ndash; this means that latency-sensitive clients can run through the same <a class="el" href="classkudu_1_1client_1_1KuduClient.html" title="A handle for a connection to a cluster. ">KuduClient</a> object as throughput-oriented clients, perhaps by setting the latency-sensitive session's timeouts low and priorities high. Without the separation of batches, a latency-sensitive single-row insert might get batched along with 10MB worth of inserts from the batch writer, thus delaying the response significantly.</p>
<p>Though we currently do not have transactional support, users will be forced to use a <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session. ">KuduSession</a> to instantiate reads as well as writes. This will make it more straight-forward to add RW transactions in the future without significant modifications to the API.</p>
<p>Users who are familiar with the Hibernate ORM framework should find this concept of a Session familiar.</p>
<dl class="section note"><dt>Note</dt><dd>This class is not thread-safe. </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="aabd55109ba3b086bbe33b277cdd40d22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classkudu_1_1client_1_1KuduSession.html#aabd55109ba3b086bbe33b277cdd40d22">kudu::client::KuduSession::ExternalConsistencyMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The possible external consistency modes on which Kudu operates. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aabd55109ba3b086bbe33b277cdd40d22ae978fab7451faebf4399830b603c855c"></a>CLIENT_PROPAGATED&#160;</td><td class="fielddoc">
<p>The response to any write will contain a timestamp. Any further calls from the same client to other servers will update those servers with that timestamp. Following write operations from the same client will be assigned timestamps that are strictly higher, enforcing external consistency without having to wait or incur any latency penalties.</p>
<p>In order to maintain external consistency for writes between two different clients in this mode, the user must forward the timestamp from the first client to the second by using <a class="el" href="classkudu_1_1client_1_1KuduClient.html#a3a671b3540c74ef7c358bb98e95031e0">KuduClient::GetLatestObservedTimestamp()</a> and <a class="el" href="classkudu_1_1client_1_1KuduClient.html#a0809b055eda76fd68988462f2a9791dd">KuduClient::SetLatestObservedTimestamp()</a>.</p>
<p>This is the default external consistency mode.</p>
<dl class="section warning"><dt>Warning</dt><dd>Failure to propagate timestamp information through back-channels between two different clients will negate any external consistency guarantee under this mode. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aabd55109ba3b086bbe33b277cdd40d22a70010f3ef1f70b99b02328c024c436c9"></a>COMMIT_WAIT&#160;</td><td class="fielddoc">
<p>The server will guarantee that write operations from the same or from other client are externally consistent, without the need to propagate timestamps across clients. This is done by making write operations wait until there is certainty that all follow up write operations (operations that start after the previous one finishes) will be assigned a timestamp that is strictly higher, enforcing external consistency.</p>
<dl class="section warning"><dt>Warning</dt><dd>Depending on the clock synchronization state of TabletServers this may imply considerable latency. Moreover operations in <code>COMMIT_WAIT</code> external consistency mode will outright fail if TabletServer clocks are either unsynchronized or synchronized but with a maximum error which surpasses a pre-configured threshold. </dd></dl>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aaec3956e642610d703f3b83b78e24e19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classkudu_1_1client_1_1KuduSession.html#aaec3956e642610d703f3b83b78e24e19">kudu::client::KuduSession::FlushMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modes of flush operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aaec3956e642610d703f3b83b78e24e19ad74b76e407e62ca951d369521636df2b"></a>AUTO_FLUSH_SYNC&#160;</td><td class="fielddoc">
<p>Every write will be sent to the server in-band with the <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> call. No batching will occur. In this mode, the <a class="el" href="classkudu_1_1client_1_1KuduSession.html#a64955abb5f5cc821b6e56354f733ce84">Flush()</a> call never has any effect, since each <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> call has already flushed the buffer. This is the default flush mode. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aaec3956e642610d703f3b83b78e24e19a520b8eef7ef0fd149b2757faf43972b1"></a>AUTO_FLUSH_BACKGROUND&#160;</td><td class="fielddoc">
<p><a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> calls will return immediately (unless there is not enough buffer space to accommodate the newly added operations), but the writes will be sent in the background, potentially batched together with other writes from the same session. If there is not sufficient buffer space, <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> blocks for buffer space to become available.</p>
<p>Because writes are applied in the background, any errors will be stored in a session-local buffer. Call <a class="el" href="classkudu_1_1client_1_1KuduSession.html#a277c213a68679c6b0d5c432919eb9198">CountPendingErrors()</a> or <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad5e3521623338de49cfd62914bdcb2f7">GetPendingErrors()</a> to retrieve them.</p>
<p>In this mode, calling the <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad8c68570479e95b325d8a5437eef8731">FlushAsync()</a> or <a class="el" href="classkudu_1_1client_1_1KuduSession.html#a64955abb5f5cc821b6e56354f733ce84">Flush()</a> methods causes a flush that normally would have happened at some point in the near future to happen right now. The <a class="el" href="classkudu_1_1client_1_1KuduSession.html#a64955abb5f5cc821b6e56354f733ce84">Flush()</a> call can be used to block until the current batch is sent and the reclaimed space is available for new operations.</p>
<dl class="section attention"><dt>Attention</dt><dd>The <code>AUTO_FLUSH_BACKGROUND</code> mode, when used in conjunction with a <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ac9a96017f86bfb6348fca9bfa0b8b5a4">KuduSession::SetMutationBufferMaxNum()</a> of greater than 1 (the default is 2), may result in out-of-order writes. This is because the buffers may flush concurrently, so multiple write operations may be sent to the server in parallel. See <a href="https://issues.apache.org/jira/browse/KUDU-1767">KUDU-1767</a> for more information.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Provide an API for the user to specify a callback to do their own error reporting. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aaec3956e642610d703f3b83b78e24e19a1db3efc2094da09aae45bb68475cdb4a"></a>MANUAL_FLUSH&#160;</td><td class="fielddoc">
<p><a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> calls will return immediately, and the writes will not be sent until the user calls <a class="el" href="classkudu_1_1client_1_1KuduSession.html#a64955abb5f5cc821b6e56354f733ce84">Flush()</a>. If the buffer runs past the configured space limit, then <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> will return an error.</p>
<dl class="section attention"><dt>Attention</dt><dd>The <code>MANUAL_FLUSH</code> mode, when used in conjunction with a <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ac9a96017f86bfb6348fca9bfa0b8b5a4">KuduSession::SetMutationBufferMaxNum()</a> of greater than 1 (the default is 2), may result in out-of-order writes if <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad8c68570479e95b325d8a5437eef8731">KuduSession::FlushAsync()</a> is used. This is because the buffers may flush concurrently, so multiple write operations may be sent to the server in parallel. See <a href="https://issues.apache.org/jira/browse/KUDU-1767">KUDU-1767</a> for more information. </dd></dl>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad3f7324b27fca298c5ca3d07b4741943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduSession::Apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkudu_1_1client_1_1KuduWriteOperation.html">KuduWriteOperation</a> *&#160;</td>
          <td class="paramname"><em>write_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Add "doAs" ability here for proxy servers to be able to act on behalf of other users, assuming access rights. </dd></dl>
<p>Apply the write operation.</p>
<p>The behavior of this function depends on the current flush mode. Regardless of flush mode, however, <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> may begin to perform processing in the background for the call (e.g. looking up the tablet, etc). Given that, an error may be queued into the PendingErrors structure prior to flushing, even in <code>MANUAL_FLUSH</code> mode.</p>
<p>In case of any error, which may occur during flushing or because the write_op is malformed, the write_op is stored in the session's error collector which may be retrieved at any time.</p>
<p>A <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session. ">KuduSession</a> accumulates write operations submitted via the <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> method in mutation buffers. A <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session. ">KuduSession</a> always has at least one mutation buffer. In any flush mode, this call may block if the maximum number of mutation buffers per session is reached (use <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ac9a96017f86bfb6348fca9bfa0b8b5a4">KuduSession::SetMutationBufferMaxNum()</a> to set the limit on maximum number of batchers).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">write_op</td><td>Operation to apply. This method transfers the write_op's ownership to the <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session. ">KuduSession</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ed0bac1edcbba612d7de41e8c8adfd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1client_1_1KuduClient.html">KuduClient</a>* kudu::client::KuduSession::client </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Client for the session: pointer to the associated client object. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5204844e361ecc3068fbc4e02fd4436"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduSession::Close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classkudu_1_1Status.html" title="A representation of an operation&#39;s outcome. ">Status</a> of the session closure. In particular, an error is returned if there are non-flushed or in-flight operations. </dd></dl>

</div>
</div>
<a class="anchor" id="af6249cf3bbad8e2e11e54edf40a7bc1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kudu::client::KuduSession::CountBufferedOperations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get number of buffered operations (not the same as 'pending').</p>
<p>Note that this is different than <a class="el" href="classkudu_1_1client_1_1KuduSession.html#a3f224e9b95f86da7e1f2ea6fcf327756">HasPendingOperations()</a> above, which includes operations which have been sent and not yet responded to.</p>
<p>This method is most relevant in <code>MANUAL_FLUSH</code> mode, where the result count stays valid until next explicit flush or <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> call. There is not much sense using this method in other flush modes: </p><ul>
<li>in <code>AUTO_FLUSH_SYNC</code> mode, the data is immediately put en-route to the destination by <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> method itself, so this method always returns zero. </li>
<li>in <code>AUTO_FLUSH_BACKGROUND</code> mode, the result count returned by this method expires unpredictably and there isn't any guaranteed validity interval for the result: the background flush task can run any moment, invalidating the result.</li>
</ul>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This method is experimental and will disappear in a future release.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of buffered operations. These are operations that have not yet been flushed &ndash; i.e. they are not en-route yet. </dd></dl>

</div>
</div>
<a class="anchor" id="a277c213a68679c6b0d5c432919eb9198"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kudu::client::KuduSession::CountPendingErrors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get error count for pending operations.</p>
<p>Errors may accumulate in session's lifetime; use this method to see how many errors happened since last call of <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad5e3521623338de49cfd62914bdcb2f7">GetPendingErrors()</a> method. The error count includes both the accumulated and dropped errors. An error might be dropped due to the limit on the error buffer size; see the <a class="el" href="classkudu_1_1client_1_1KuduSession.html#af1c5e5e8faba286cddc266057e9a82d5">SetErrorBufferSpace()</a> method for details.</p>
<dl class="section return"><dt>Returns</dt><dd>Total count of errors accumulated during the session. </dd></dl>

</div>
</div>
<a class="anchor" id="a64955abb5f5cc821b6e56354f733ce84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduSession::Flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush any pending writes.</p>
<p>This method initiates flushing of the current batch of buffered write operations, if any, and then awaits for completion of all pending operations of the session. I.e., after successful return from this method no pending operations should be left in the session.</p>
<p>In <code>AUTO_FLUSH_SYNC</code> mode, calling this method has no effect, since every <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> call flushes itself inline.</p>
<dl class="section return"><dt>Returns</dt><dd>Operation result status. In particular, returns a non-OK status if there are any pending errors after the rows have been flushed. Callers should then use GetPendingErrors to determine which specific operations failed. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8c68570479e95b325d8a5437eef8731"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kudu::client::KuduSession::FlushAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkudu_1_1client_1_1KuduStatusCallback.html">KuduStatusCallback</a> *&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush any pending writes asynchronously.</p>
<p>This method schedules a background flush of the latest batch of buffered write operations. Provided callback is invoked upon the flush completion of the latest batch of buffered write operations. If there were errors while flushing the operations, corresponding 'not OK' status is passed as a parameter for the callback invocation. Callers should then use <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad5e3521623338de49cfd62914bdcb2f7">GetPendingErrors()</a> to determine which specific operations failed.</p>
<p>In the case that the async version of this method is used, then the callback will be called upon completion of the operations which were buffered since the last flush. In other words, in the following sequence: </p><div class="fragment"><div class="line">session-&gt;Insert(a);</div><div class="line">session-&gt;FlushAsync(callback_1);</div><div class="line">session-&gt;Insert(b);</div><div class="line">session-&gt;FlushAsync(callback_2);</div></div><!-- fragment --><p> ... <code>callback_2</code> will be triggered once <code>b</code> has been inserted, regardless of whether <code>a</code> has completed or not. That means there might be pending operations left in prior batches even after the callback has been invoked to report on the flush status of the latest batch.</p>
<dl class="section note"><dt>Note</dt><dd>This also means that, if FlushAsync is called twice in succession, with no intervening operations, the second flush will return immediately. For example: <div class="fragment"><div class="line">session-&gt;Insert(a);</div><div class="line">session-&gt;FlushAsync(callback_1); <span class="comment">// called when &#39;a&#39; is inserted</span></div><div class="line">session-&gt;FlushAsync(callback_2); <span class="comment">// called immediately!</span></div></div><!-- fragment --> Note that, as in all other async functions in Kudu, the callback may be called either from an IO thread or the same thread which calls FlushAsync. The callback should not block.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback to call upon flush completion. The <code>cb</code> must remain valid until it is invoked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad5e3521623338de49cfd62914bdcb2f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kudu::client::KuduSession::GetPendingErrors </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classkudu_1_1client_1_1KuduError.html">KuduError</a> * &gt; *&#160;</td>
          <td class="paramname"><em>errors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>overflowed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get information on errors from previous session activity.</p>
<p>The information on errors are reset upon calling this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">errors</td><td>Pointer to the container to fill with error info objects. Caller takes ownership of the returned errors in the container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">overflowed</td><td>If there were more errors than could be held in the session's error buffer, then <code>overflowed</code> is set to <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f224e9b95f86da7e1f2ea6fcf327756"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool kudu::client::KuduSession::HasPendingOperations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if there are any pending operations in this session.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there are operations which have not yet been delivered to the cluster. This may include buffered operations (i.e. those that have not yet been flushed) as well as in-flight operations (i.e. those that are in the process of being sent to the servers).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Maybe "incomplete" or "undelivered" is clearer? </dd></dl>

</div>
</div>
<a class="anchor" id="af1c5e5e8faba286cddc266057e9a82d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduSession::SetErrorBufferSpace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size_bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set limit on maximum buffer (memory) size used by this session's errors. By default, when a session is created, there is no limit on maximum size.</p>
<p>The session's error buffer contains information on failed write operations. In most cases, the error contains the row which would be applied as is. If the error buffer space limit is set, the number of errors which fit into the buffer varies depending on error conditions, write operation types (insert/update/delete), and write operation row sizes.</p>
<p>When the limit is set, the session will drop the first error that would overflow the buffer as well as all subsequent errors. To resume the accumulation of session errors, it's necessary to flush the current contents of the error buffer using the <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad5e3521623338de49cfd62914bdcb2f7">GetPendingErrors()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size_bytes</td><td>Limit on the maximum memory size consumed by collected session errors, where <code>0</code> means 'unlimited'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation result status. An error is returned on an attempt to set the limit on the buffer space if: <ul>
<li>the session has already dropped at least one error since the last call to the <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad5e3521623338de49cfd62914bdcb2f7">GetPendingErrors()</a> method </li>
<li>the new limit is less than the amount of space occupied by already accumulated errors. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a56d1c7f47dfcaf5121b15a4435a8eeca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduSession::SetExternalConsistencyMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#aabd55109ba3b086bbe33b277cdd40d22">ExternalConsistencyMode</a>&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set external consistency mode for the session.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>External consistency mode to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="a83555781b5a037f87c215e565ecf1a8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduSession::SetFlushMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#aaec3956e642610d703f3b83b78e24e19">FlushMode</a>&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the flush mode.</p>
<dl class="section pre"><dt>Precondition</dt><dd>There should be no pending writes &ndash; call <a class="el" href="classkudu_1_1client_1_1KuduSession.html#a64955abb5f5cc821b6e56354f733ce84">Flush()</a> first to ensure nothing is pending.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Flush mode to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>

</div>
</div>
<a class="anchor" id="aabe75f0688f992dbdb2694a50d07f941"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduSession::SetMutationBufferFlushInterval </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>millis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the interval for time-based flushing of the mutation buffer.</p>
<p>In some cases, while running in AUTO_FLUSH_BACKGROUND mode, the size of the mutation buffer for pending operations and the flush watermark for fresh operations may be too high for the rate of incoming data: it would take too long to accumulate enough data in the buffer to trigger flushing. I.e., it makes sense to flush the accumulated operations if the prior flush happened long time ago. This method sets the wait interval for the time-based flushing which takes place along with the flushing triggered by the over-the-watermark criterion. By default, the interval is set to 1000 ms (i.e. 1 second).</p>
<dl class="section note"><dt>Note</dt><dd>This setting is applicable only for AUTO_FLUSH_BACKGROUND sessions. I.e., calling this method in other flush modes is safe, but the parameter has no effect until the session is switched into AUTO_FLUSH_BACKGROUND mode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">millis</td><td>The duration of the interval for the time-based flushing, in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="a7311344cec37b3847217197c35467cdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduSession::SetMutationBufferFlushWatermark </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>watermark_pct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the buffer watermark to trigger flush in AUTO_FLUSH_BACKGROUND mode.</p>
<p>This method sets the watermark for fresh operations in the buffer when running in AUTO_FLUSH_BACKGROUND mode: once the specified threshold is reached, the session starts sending the accumulated write operations to the appropriate tablet servers. By default, the buffer flush watermark is to to 50%.</p>
<dl class="section note"><dt>Note</dt><dd>This setting is applicable only for AUTO_FLUSH_BACKGROUND sessions. I.e., calling this method in other flush modes is safe, but the parameter has no effect until the session is switched into AUTO_FLUSH_BACKGROUND mode.</dd>
<dd>
The buffer contains data for fresh (i.e. newly submitted) operations and also operations which are scheduled for flush or being flushed. The flush watermark determines how much of the buffer space is taken by newly submitted operations. Setting this level to 1.0 (i.e. 100%) results in flushing the buffer only when the newly applied operation would overflow the buffer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">watermark_pct</td><td>Watermark level as percentage of the mutation buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9a96017f86bfb6348fca9bfa0b8b5a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduSession::SetMutationBufferMaxNum </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the maximum number of mutation buffers per <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session. ">KuduSession</a> object.</p>
<p>A <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session. ">KuduSession</a> accumulates write operations submitted via the <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> method in mutation buffers. A <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session. ">KuduSession</a> always has at least one mutation buffer. The mutation buffer which accumulates new incoming operations is called the <em>current mutation buffer</em>. The current mutation buffer is flushed either explicitly using the <a class="el" href="classkudu_1_1client_1_1KuduSession.html#a64955abb5f5cc821b6e56354f733ce84">KuduSession::Flush()</a> and/or <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad8c68570479e95b325d8a5437eef8731">KuduSession::FlushAsync()</a> methods or it's done by the <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session. ">KuduSession</a> automatically if running in AUTO_FLUSH_BACKGROUND mode. After flushing the current mutation buffer, a new buffer is created upon calling <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">KuduSession::Apply()</a>, provided the limit is not exceeded. A call to <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">KuduSession::Apply()</a> blocks if it's at the maximum number of buffers allowed; the call unblocks as soon as one of the pending batchers finished flushing and a new batcher can be created.</p>
<p>The minimum setting for this parameter is 1 (one). The default setting for this parameter is 2 (two).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_num</td><td>The maximum number of mutation buffers per <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session. ">KuduSession</a> object to hold the applied operations. Use <code>0</code> to set the maximum number of concurrent mutation buffers to unlimited. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="aefa9bbc51c27104ce103b9ecda3b8abf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduSession::SetMutationBufferSpace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size_bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the amount of buffer space used by this session for outbound writes.</p>
<p>The effect of the buffer size varies based on the flush mode of the session: </p><ul>
<li>AUTO_FLUSH_SYNC since no buffering is done, this has no effect. </li>
<li>AUTO_FLUSH_BACKGROUND if the buffer space is exhausted, then write calls will block until there is space available in the buffer. </li>
<li>MANUAL_FLUSH if the buffer space is exhausted, then write calls will return an error</li>
</ul>
<p>By default, the buffer space is set to 7 MiB (i.e. 7 * 1024 * 1024 bytes).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size_bytes</td><td>Size of the buffer space to set (number of bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="a25b22362650d7120f59cc1025e40bd79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kudu::client::KuduSession::SetTimeoutMillis </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>millis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the timeout for writes made in this session.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">millis</td><td>Timeout to set in milliseconds; should be greater or equal to 0. If the parameter value is less than 0, it's implicitly set to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/kudu/client/<a class="el" href="client_8h_source.html">client.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer">
  <small>Generated for Kudu version 1.9.0 on Fri Mar 8 2019 03:36:22 by Doxygen 1.8.11</small>
  <br>
  <small>Copyright  2019 The Apache Software Foundation.</small>
</address>
</body>
</html>
